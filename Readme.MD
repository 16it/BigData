## SQLite单表4亿订单，大数据测试  
`SQLite`作为嵌入式数据库的翘楚，广受欢迎！  
新生命团队自2010年以来，投入大量精力对`SQLite`进行学习研究，成功应用于各系统非致命数据场合。  

### SQLite极致性能
+ 关闭同步，Synchronous=Off，提升性能。添删改操作时不必同步等待写入磁盘，操作系统会延迟若干毫秒批量写入  
+ 设置WAL模式，Journal Mode=WAL，减少锁定。写入向前日志模式，避免多线程访问时锁定数据库，写入时不必使用排它锁影响其它线程读取，而是把事务操作写入到WAL文件中，延迟合并  
+ 加大缓存，Cache Size=5000，提升性能。操作系统通过文件映射MapFile把整个数据库文件映射进入内存，实际查询时会把用到数据所在附近页预先加载进入缓存，极大提升查询性能  
+ 插入速度 5000~16000tps，依赖CPU，HDD/SSD差别不大，主要受限于SQLite.Data.dll的Prepare  
+ 查询速度 非首次查询，缓存命中以后，索引查询基本上都是毫秒级。数据库较大则相应加大缓存，速度不变。  
+ 查记录数 单表数据超过一千万行以后，尽量不要使用Select Count，否则可能需要十几秒到半分钟的样子才能返回。NewLife.XCode封装了'Meta.Count'  

当然，SQLite不适合多线程高并发写入，多线程高并发读取倒是非常不错。  
因为数据库就在进程内，高并发读取一般比其它RDS要快一大截。  
总的来说，SQLite数据库甭管多少数据多大库文件，只要配置得当，内存管够，性能不是太大问题！  

### SQLite大数据
为了验证SQLite的性能巅峰，我们来做一个大数据测试。  
模拟每天4亿票销售订单，分表分库，每天一个数据库文件，有订单号、部门节点、时间等。  


#### 1, Test项目生成4亿行订单数据，主键自增ID，订单号建立索引，文件大小26.5G  
![生成](Doc/0.png)


#### 2, Web项目，魔方+XCode，首次查询较慢，约427毫秒，需要预热  
![Web](Doc/1.png)

3, 设置缓存Cache Size=2000，因数据库文件过大，太大缓存会报内存不足异常  
4, 跳转到两万多页，查询1.6秒，前后页耗时毫秒级，操作系统文件映射缓存生效  
5, 查询任意订单号，耗时16毫秒以内，索引效果强大  
6, 本地内存占用250M

http://bigdata.newlifex.com/Admin

### SQLite低要求
+ 租用阿里云最低配置ECS，单核1G，1M带宽，每年300块，每天九毛钱
+ 部署BigData项目到ECS，访问正常
+ 首次查询十几秒
